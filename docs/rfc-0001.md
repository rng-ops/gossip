# RFC-0001: TerrainGossip LLM Mesh Protocol
**Status:** Draft  
**Version:** 0.1  
**Authors:** (Project contributors)  
**Last-Updated:** 2026-01-09  
**License:** MIT OR Apache-2.0  
**Audience:** Engineers implementing Rust + TypeScript distributed systems; privacy-aware networking; ML serving

---

## 0. Abstract

TerrainGossip defines a decentralized protocol for:

1) **Distributed LLM inference** across independently-operated provider nodes  
2) **Continuous benchmarking** through signed probe receipts and behavior attestations  
3) **Gossip-based routing** using local belief fields (no canonical global score)  
4) **Private, mixed request routing** using onion-style multi-hop circuits (Tor-like)  
5) **Forkable “worlds”** where addressing and governance are derived from a phrase seed and ruleset hash  
6) **Vector-memory event storage** and **delta synchronization** (append-only event log + incremental embedding index updates)  
7) **Optional training plugins** (LoRA/QLoRA/etc.) where behavior changes are detected via benchmarks and reflected in routing

**Critical invariants:**
- There is **no canonical global score**. Nodes compute beliefs locally from signed events.
- Providers do **not** control their behavioral identity labels; these are **observer-assigned**.
- Providers can see a **delayed/noisy self-view level**, but cannot know the **external handle** other peers use to refer to them.
- Egress probers may lie; the protocol assumes noisy sensors and uses robust aggregation + disputes.
- Governance is forkable by construction: world identity commits to a ruleset hash.

---

## 1. Goals and Non-Goals

### 1.1 Goals
- Enable private LLM inference by routing encrypted requests through multiple relay hops so no single node learns both (origin, content, destination).
- Support heterogeneous providers (different models, runtimes, LoRA adapters) without central coordination.
- Continuously measure provider behavior and quality using probe nodes, and route requests using local belief fields that converge statistically.
- Provide an append-only, verifiable event substrate that can be shared as deltas and indexed in vector memory for retrieval, anomaly detection, and auditability.
- Make “worlds” forkable and rule-bound via phrase-derived identifiers.

### 1.2 Non-Goals
- This RFC does **not** define a blockchain, global ledger, or globally-consistent scoring.
- This RFC does **not** promise resistance against a global passive adversary performing perfect timing correlation across the entire internet. (See Threat Model.)
- This RFC does **not** implement “covert channels” or protocol mimicry. The goal is privacy and censorship resistance, not stealth malware.

---

## 2. Terminology

### 2.1 Node Roles
- **Provider (Inference Node):** Serves LLM inference. Publishes a **Capability Manifest** (FAH). Does not publish behavioral identity.
- **Router:** Accepts client tasks and selects providers using local beliefs, compatibility rules, and exploration/exploitation.
- **Prober:** Runs benchmark suites against providers and emits signed **ProbeReceipts** and **BehaviorAttestations**.
- **Egress Prober:** Prober with internet access for externally anchored challenges. May lie; treated as noisy sensor.
- **Gossipd (Memory Node):** Stores append-only Event Log + vector memory index; provides delta sync and semantic queries.
- **Verifier (Optional Plugin):** Validates training shards and/or attestations; emits signed VerdictEvents.
- **Curator (Optional Plugin):** Redacts/distills opt-in training contributions into Training Data Shards (TDS).
- **Trainer (Optional Plugin):** Trains LoRA/QLoRA/etc. from verified shards; publishes Training Manifest.
- **Indexer (Optional Component):** Embedding worker and search API for shards/events.

### 2.2 Core Concepts
- **World:** An overlay network defined by a phrase seed and a rule bundle hash.
- **Terrain:** Deterministic overlay “map” used for neighbor selection and routing topology.
- **Phrase Address:** Human mnemonic encoding of a coordinate/location within a world (UX label; not identity).
- **Event Log:** Append-only set of signed events (receipts, attestations, disputes, endorsements, etc.).
- **Delta Sync:** Protocol to exchange new events since a causal clock, enabling partial replication.
- **Vector Memory:** Embedding index over event summaries and shard metadata used for retrieval and anomaly detection.
- **Belief Field:** Each node’s local posterior estimates about provider quality/behavior.

---

## 3. Formal Identifiers and Cryptographic Objects

### 3.1 Canonical Encoding
All hashed and signed objects MUST be serialized using a single canonical encoding.

**Normative choice (v0.1):** canonical bytes are `postcard` (Serde) serialization of the Rust reference structs.

**Constraints (MUST):**
- No maps / hashmaps in any signed/hashed struct.
- All floats (`f32`/`f64`) in signed/hashed structs MUST be finite (no NaN/±Inf) and MUST be normalized such that `-0.0` is encoded as `+0.0`.
- Strings are UTF-8.
- Field order is the Rust struct field order.
- **Repeated field ordering:** Any `repeated` field that participates in hashing/signing MUST be deterministically ordered before serialization:
  - `contact_points`: sorted lexicographically (UTF-8 byte order), deduplicated
  - `adapters`: sorted by `(adapter_type, adapter_id, adapter_digest)` lexicographically
  - `shard_ids`: sorted by raw bytes
  - All other repeated fields: sorted by their canonical byte representation
- **ID fields:** Transmitted `event_id`, `receipt_id`, `attestation_id`, `descriptor_id` fields MUST equal the computed hash of the object's canonical bytes; implementations MUST reject messages where computed ≠ transmitted.

**Hashing/signing rule:** Protobuf decoding MUST NOT be hashed/signed directly. Implementations MUST decode Protobuf → construct the corresponding Rust/TS struct → re-encode using the canonical encoding → then hash/sign/verify.

**Test vectors:** Rust MUST generate test vectors for `WorldId`, `RuleBundleHash`, `FAH`, `DescriptorId`, `TargetRef`, and at least one `ProbeReceipt`/`BehaviorAttestation` signature. TypeScript MUST validate by reproducing the canonical bytes exactly.

### 3.2 World Identity
A world commits to rules by construction.

**Inputs:**
- `world_phrase`: 3–4 words, normalized (lowercase, trimmed, single hyphens)
- `rule_bundle_hash`: `H(canonical_bytes(RuleBundle))`

**Definition:**
- `WorldId = BLAKE3("world" || world_phrase_norm || rule_bundle_hash)` (32 bytes)

**Property:** Changing rules changes `WorldId`, yielding a forkable world by default.

### 3.3 Terrain Coordinates and Phrase Addresses
A **TerrainAddress** is a location coordinate used for overlay topology and rendezvous.

- `TerrainAddress = (epoch_id, region_id, chunk_id, cell_id)`

A **PhraseAddress** encodes a TerrainAddress for humans (e.g., `"cable-lantern-kiwi-slate"`).
- PhraseAddress is UX-only; MUST NOT be treated as an identity key.
- Encode payload bytes + checksum into base-|W| digits mapped to a wordlist.

### 3.4 Transport Identity
Nodes maintain a transport keypair for authentication and secure channels.

- `TransportKeypair`: Ed25519 (or equivalent)
- `TransportPubKey` authenticates a session, not global routing identity.

### 3.5 Capability Manifest and FAH (Functional Address Hash)
Providers publish a manifest describing what they can serve.

**CapabilityManifest includes:**
- base_model_id (string)
- weights_digest (bytes32)
- runtime_id (enum: ollama/vllm/llamacpp/other)
- context_limit (u32)
- supported_modalities (bitset)
- tool_schemas_digest (bytes32)
- safety_mode (enum)
- optional adapters list (IDs and digests)
- pricing/limits (optional; local policy)

**FAH definition:**
- `FAH = BLAKE3("fah" || canonical_bytes(CapabilityManifest))`

FAH is provider-controlled and content-addressed (claim of capability), not a behavior rating.

### 3.6 Observer Handle (Local Pseudonym)
Each observer assigns a local handle to a provider.

**Definition:**
- Each observer has `observer_secret` (32 bytes).
- `observed_fingerprint(provider)` is derived from handshake evidence (e.g., ephemeral session transcript hash) such that it does NOT reveal provider’s stable self-identity to the provider.

- `Handle_o(provider) = BLAKE3("handle" || observer_secret || observed_fingerprint)` (32 bytes)

**Properties:**
- Different observers produce different handles for the same provider.
- Providers cannot compute or see the handles other peers use for them.
- Handle linking is partial, evidence-based, and local (no global identity).

**Hard rule:** `Handle` is strictly local bookkeeping and MUST NOT appear in gossiped/delta-synced events.

### 3.7 Control-Plane TargetRef (World-Scoped, Provider-Blind)
Control-plane events need a reference that is (a) shareable among routers/probers, (b) stable enough for aggregation, and (c) not computable by the provider.

**Definition:**
- Providers publish `ProviderDescriptor` objects (see §3.8) which have a content address `DescriptorId`.
- Control-plane members share a secret `control_plane_key` (32 bytes) per world (distribution out of scope; see §4.0).

- `TargetRef = BLAKE3_KEYED(control_plane_key, "targetref" || WorldId || DescriptorId)` (32 bytes)

**Properties:**
- Everyone with the world’s `control_plane_key` derives the same `TargetRef` from the same `DescriptorId`.
- Providers cannot compute `TargetRef` (lack `control_plane_key`).
- Providers MUST NOT be able to observe control-plane `TargetRef` values on the wire (control-plane messages are membership-gated and/or encrypted).

### 3.8 Provider Descriptor and DescriptorId (Inference Reachability)
The protocol requires an explicit “how do we reach providers?” object.

**ProviderDescriptor (unsigned fields):**
- `world_id`
- `descriptor_epoch` (rotates at least per epoch)
- `contact_points` (e.g., rendezvous tokens, onion addresses, multiaddrs)
- `capability_manifest` or `FAH`

**DescriptorId:**
- `DescriptorId = BLAKE3("descriptor" || canonical_bytes(ProviderDescriptorUnsigned))` (32 bytes)

**Signing:** Provider signs the descriptor for authenticity and anti-tamper, but the descriptor MUST NOT contain anything that lets the provider infer `TargetRef`.

### 3.9 BAH (Behavioral Address Hash)
Behavior labels are assigned by observers from aggregated attestations.

**Definition (epoch window e):**
- `AggMetrics_e(handle_class)` is a canonical aggregate of metrics from multiple probers.
- Optionally include verifier committee signatures.

- `BAH_e = BLAKE3("bah" || FAH || epoch_id || canonical_bytes(AggMetrics_e) || optional_verifier_multisig)` (32 bytes)

**Note:** BAH may differ between nodes/worlds if they aggregate differently. That is acceptable; do not force a global BAH.

### 3.10 Probe Receipts and Attestations
Two distinct objects:

**ProbeReceipt** (proof that a probe happened):
- signed, replay-resistant, cheap to verify
- binds probe to epoch, challenge, `TargetRef`, and a commitment to results

**BehaviorAttestation** (metrics report):
- signed, includes metrics vector and commitments
- may reference freshness anchors (weak or strong)

---

## 4. Protocol Spine

TerrainGossip is built around one spine:

> **Append-only Event Log → Delta Sync → Vector Memory Index → Local Belief Field → Routing Decisions**

### 4.0 Two Planes: Inference vs Control (Normative)
TerrainGossip separates two planes to preserve provider blindness and make aggregation workable across observers:

- **Inference Plane:** onion-routed client requests/responses. Providers participate here.
- **Control Plane:** benchmarking receipts/attestations/disputes/link-hints, descriptor discovery, and event-log delta sync. Providers MUST NOT be able to read control-plane traffic and SHOULD NOT participate as control-plane replicas.

**Membership gating / encryption (v0.1):**
- Delta sync is a control-plane protocol between `routerd`/`prober`/`gossipd` nodes.
- Providers are not authorized control-plane participants.
- Deployments MAY still route control-plane packets over provider-operated relays, but then control-plane packets MUST be application-layer encrypted (AEAD) to prevent providers from observing `TargetRef`.

### 4.1 Event Log
Each node maintains a local append-only log of events:
- ReceiptEvent
- AttestationEvent
- DisputeEvent
- LinkHintEvent
- RuleBundleEndorsementEvent
- Optional: ShardEvent, VerdictEvent, TrainingManifestEvent

Events are immutable and identified by `EventId = H(canonical_bytes(event))`.

### 4.2 Delta Sync
Nodes sync by requesting events since a causal clock:
- version vectors or dotted version vectors
- receiver verifies signatures and inserts new events
- vector memory index is updated incrementally for new events

**Replica identity constraint:** version vectors MUST NOT be keyed by long-lived transport pubkeys on the wire. Use rotating `replica_id` values (see §11 schema) and/or restrict delta sync membership to control-plane nodes.

### 4.3 Vector Memory
Each node stores embeddings for:
- event summaries (not raw private content)
- shard metadata (optional plugin)
Embeddings enable:
- semantic retrieval (“why did we downrank this provider?”)
- anomaly detection (clustering liar sensors, poisoning patterns, regressions)
- dataset assembly (optional plugin)

### 4.4 Belief Field
Each node computes local beliefs from events:
- `belief[handle_or_class] = {mu, sigma, trend, disagreement}`
Belief is computed locally; it is NOT a gossip payload.

### 4.5 Routing Decisions
Routers select providers based on:
- compatibility with task and FAH
- belief score (mu) and uncertainty (sigma)
- disagreement penalty
- exploration schedule (ε-greedy / Thompson sampling / UCB)
- privacy constraints (avoid selecting relays in same cluster, etc.)

---

## 5. Privacy and Mixing: Circuit Routing

### 5.1 Threat Model Summary
The protocol aims for:
- relay unlinkability: no single node learns both origin and plaintext
- basic resistance to local observers and single-hop adversaries
It does NOT guarantee:
- perfect protection against a global passive adversary timing-correlating all traffic

### 5.2 Circuit Construction (Onion-Style)
A client (or entry router acting for a client) constructs a circuit of length L (default 3):
- Entry → Middle → Exit (provider)
Messages are layered-encrypted so each hop only knows next hop.

**Implementation options:**
- Use an application-layer onion scheme with ephemeral per-hop keys.
- Optionally run transport over Tor/I2P as a deployment choice (out of spec).

### 5.3 Mixing and Padding
To reduce correlation:
- fixed-size cells where possible
- optional batching at relays (bounded delays)
- cover traffic (optional, rate-limited)
This RFC defines hooks; the baseline implementation may start without heavy mixing.

### 5.4 Provider Blindness Requirements
Providers MUST NOT learn:
- the observer handles used to route to them
- which requests are tests vs real (as much as feasible)
Provider MAY learn:
- local self-view “level” (delayed/noisy, derived from inbound events)

### 5.5 Minimal Onion Wire Messages (v0)
To prevent implementation drift, the inference plane defines a minimal circuit/cell schema.

**Crypto (normative):**
- Per-hop key agreement: X25519 + HKDF
- Payload encryption: AEAD (ChaCha20-Poly1305 or AES-256-GCM)
- Fixed-size payloads are used when `RuleBundle.fixed_cell_bytes > 0`.

---

## 6. Benchmarking: Probes, Receipts, and Attestations

### 6.1 Challenge Types
- **Synthetic Canary:** deterministic prompt + property checks (no web)
- **Tool Fidelity:** function-call correctness against mock tools
- **Metamorphic Tests:** paraphrase invariants / perturbation stability
- **Egress Anchored Tests:** external fetch/parse challenges (weak or strong freshness)

### 6.2 Metrics Vector (example fields)
- success_rate (0..1)
- refusal_consistency (0..1)
- tool_fidelity (0..1)
- latency_p50_ms, latency_p95_ms
- robustness_score (0..1)
- drift_indicator (signed)
- policy_alignment (world-local)
- freshness_strength (enum: none/weak/strong)

### 6.3 ProbeReceipt Structure
Receipt binds:
- epoch_id
- challenge_id commitment (MUST NOT be a literal prompt ID)
- `TargetRef` (control-plane, provider-blind)
- outcome_commitment (hash)
- optional anti-spam ticket (scrypt/argon2)
- signature by prober transport key

### 6.4 BehaviorAttestation Structure
Attestation binds:
- epoch_id
- challenge_id commitment (or suite commitment)
- `TargetRef`
- metrics vector
- evidence_commitment (hash of redacted evidence)
- freshness anchor (optional)
- signature by prober transport key

### 6.6 Probe Anti-Detection (Normative)
Because providers can fingerprint static benchmark prompts, probes MUST incorporate anti-detection measures:
- Probes MUST be metamorphic / randomized per epoch (e.g., paraphrases, equivalent problem instances).
- A portion of probes MUST be indistinguishable from normal traffic (same routing, padding, and mixing policy).
- `ChallengeId` values are commitments; they MUST NOT reveal the underlying prompt/test-case identity.

### 6.5 Disputes
Disputes are raised when:
- two attestations strongly conflict beyond tolerance
- or provable fraud is detected (invalid sig, invalid commitment)
Dispute actions:
- increase redundancy (more probes)
- downweight liar sensors
- slash only provable fraud (implementation policy)

---

## 7. Gossip and “No Canonical Score”

### 7.1 What Is Gossiped
Only signed events and rule endorsements:
- receipts
- attestations
- disputes
- link hints
- rule bundle endorsements
- optional shard and training events

### 7.2 What Is NOT Gossiped
- An authoritative “score”
- A global leaderboard
- Provider-chosen behavioral IDs

### 7.3 Statistical Convergence
Even without a canonical score:
- nodes’ local beliefs converge because they ingest overlapping event evidence
- divergence is expected under network partitions and is acceptable

---

## 8. Game Theory and Incentive Mechanics

This system is a repeated game among:
- Providers (want traffic, reputation, possibly payment)
- Probers (want influence/standing; possibly payment)
- Routers (want reliable service for their users)
- Adversaries (want to bias routing or deanonymize)

### 8.1 Strategy Space
Providers choose:
- model/runtime
- adapter plugins (LoRA)
- resource allocation (latency vs cost)
- whether to respond to tasks, refusal policy
Probers choose:
- which targets to probe
- how honestly to report
Routers choose:
- routing policy
- trust weighting and redundancy
Adversaries choose:
- sybils, collusion, lying egress, selective answering, targeted manipulation

### 8.2 Desired Equilibrium (Informal)
We want an equilibrium where:
- honest probers gain trust because their attestations predict others’ observations
- liars lose trust because they increase disagreement and fail predictive checks
- providers improve service to attract routing traffic (becoming attractors)
- providers that degrade or cheat lose traffic (repellors)
- sybil attacks are costly due to probe tickets, diversity constraints, and correlation penalties

### 8.3 Sybil and Collusion Resistance
Mechanisms:
- **Proof-of-probe cost:** probing requires time/bandwidth; optionally include scrypt/argon2 ticket for influence weight
- **Diversity requirements:** promotions require attestations from diverse probers/clusters
- **Anti-correlation penalties:** endorsements from tightly correlated clusters saturate
- **Robust aggregation:** median/trimmed mean reduces liar impact
- **Exploration floor:** routers always explore some new providers; prevents cartel lock-in

### 8.4 Trust and Influence as a Function of Predictiveness
Each node maintains a trust score `T(prober)` updated by predictive accuracy:
- if prober’s attestations align with later consensus (under diversity), trust increases
- if prober diverges repeatedly, trust decreases
This makes “lying” a dominated strategy unless attacker controls most diverse probers.

### 8.5 Provider Behavior Drift and Adapter Quality
Providers can load new LoRAs or change models at any time.
- if improvements are real, probes trend upward and routing converges toward them
- if degradation or maliciousness occurs, probes detect drift, disagreement rises, routing diverges away

---

## 9. Governance: Rule Bundles and World Forking

### 9.1 RuleBundle
A RuleBundle is a versioned config that defines:
- epoch length
- acceptable challenge suites
- metrics weights
- disagreement thresholds
- diversity requirements
- dispute triggers
- optional content policy baseline
- mixing parameters defaults

RuleBundle is hashed and committed into WorldId.

### 9.2 Endorsement and Activation
Nodes may gossip endorsements:
- EndorsementEvent {bundle_hash, weight, signer}
Activation is local policy:
- activate bundle if endorsement weight exceeds threshold for M epochs
Worlds fork naturally when participants choose different bundles.

---

## 10. Optional Plugin: Training Data Shards and LoRA Publishing

This is OPTIONAL. The core protocol is inference + benchmarking + gossip routing.

### 10.1 Training Data Shard (TDS)
TDS is content-addressed and includes:
- shard_id = BLAKE3(canonical_bytes(shard))
- source_type: opt-in lesson | synthetic | public benchmark
- redacted/distilled content (no private raw logs by default)
- embedding vector (optional; can be computed by indexer)
- curator signature

### 10.2 Verification and Indexing
Verifier nodes issue VerdictEvents:
- signature validity
- dedupe (hash + embedding similarity)
- safety classification (world-local rules)
- poisoning heuristics (anomaly patterns)

Indexers store shard embeddings in vector DB for semantic retrieval.

### 10.3 Training Manifest
Trainers publish:
- model artifact digest
- base model id
- list of shard ids + weights
- training method parameters
- eval report digest

### 10.4 How Training Affects Routing
Training itself is not trusted automatically.
Providers serving new adapters are evaluated via probes:
- if adapter improves measured metrics, routing will converge toward them
- if adapter worsens or is malicious, routing diverges away

---

## 11. Protocol Messages (Protobuf)

This section defines the normative wire schema.
All byte fields are raw bytes; hashes are 32 bytes unless specified.

> NOTE: Protobuf is for interchange. Canonical bytes for hashing/signing MUST follow the canonical encoding rules in the Rust reference (see §3.1) and validated by test vectors.

### 11.1 Protobuf Schema (terrain_gossip.proto)

```proto
syntax = "proto3";
package terraingossip.v1;

message Bytes32 { bytes v = 1; }
message Bytes64 { bytes v = 1; }

enum FreshnessStrength {
  FRESH_NONE = 0;
  FRESH_WEAK = 1;
  FRESH_STRONG = 2;
}

enum EventType {
  EVENT_UNSPECIFIED = 0;
  EVENT_RECEIPT = 1;
  EVENT_ATTESTATION = 2;
  EVENT_DISPUTE = 3;
  EVENT_LINK_HINT = 4;
  EVENT_RULE_ENDORSEMENT = 5;
  EVENT_SHARD = 6;
  EVENT_VERDICT = 7;
  EVENT_TRAINING_MANIFEST = 8;
  EVENT_DESCRIPTOR_PUBLISH = 9;
}

message WorldId { Bytes32 id = 1; }

message RuleBundle {
  uint32 version = 1;
  uint64 epoch_len_ms = 2;
  double exploration_rate = 3;
  double disagreement_quarantine_threshold = 4;
  uint32 min_diverse_probers = 5;
  uint32 max_probe_redundancy = 6;
  // Mixing defaults (baseline; world may override locally)
  uint32 default_circuit_len = 7;
  uint32 relay_batch_max_delay_ms = 8;
  uint32 fixed_cell_bytes = 9;
  // Metrics weights (example)
  double w_success = 20;
  double w_tool_fidelity = 21;
  double w_latency = 22;
  double w_refusal_consistency = 23;
  double w_robustness = 24;
}

message TerrainAddress {
  uint64 epoch_id = 1;
  uint64 region_id = 2;
  uint64 chunk_id = 3;
  uint32 cell_id = 4;
}

message CapabilityManifest {
  string base_model_id = 1;
  Bytes32 weights_digest = 2;
  string runtime_id = 3;
  uint32 context_limit = 4;
  Bytes32 tool_schemas_digest = 5;
  string safety_mode = 6;
  repeated Adapter adapters = 7;

  message Adapter {
    string adapter_id = 1;
    Bytes32 adapter_digest = 2;
    string adapter_type = 3; // e.g. "lora"
  }
}

message FAH { Bytes32 h = 1; }

// Observer-local handle (32 bytes)
message Handle { Bytes32 h = 1; }

// World-scoped control-plane reference (32 bytes, provider-blind)
message TargetRef { Bytes32 h = 1; }

// Optional behavior label (32 bytes)
message BAH { Bytes32 h = 1; }

message ChallengeId { Bytes32 h = 1; }
message ReceiptId { Bytes32 h = 1; }
message AttestationId { Bytes32 h = 1; }
message EventId { Bytes32 h = 1; }

message DescriptorId { Bytes32 h = 1; }

message ProbeTicket {
  // Optional anti-spam / influence ticket (scrypt/argon2 output)
  bytes ticket_bytes = 1;
  uint32 params_n = 2;
  uint32 params_r = 3;
  uint32 params_p = 4;
}

message OutcomeCommitment { Bytes32 h = 1; }
message EvidenceCommitment { Bytes32 h = 1; }

message MetricsVector {
  double success_rate = 1;
  double refusal_consistency = 2;
  double tool_fidelity = 3;
  uint32 latency_p50_ms = 4;
  uint32 latency_p95_ms = 5;
  double robustness_score = 6;
  double drift_indicator = 7;
  FreshnessStrength freshness = 8;
}

message ProbeReceipt {
  ReceiptId receipt_id = 1;
  WorldId world = 2;
  uint64 epoch_id = 3;
  ChallengeId challenge_id = 4;
  TargetRef target_ref = 5;
  optional FAH target_fah = 6; // optional binding for capability class
  OutcomeCommitment outcome_commitment = 7;
  optional ProbeTicket ticket = 8;
  bytes prober_transport_pubkey = 9;
  bytes signature = 10; // signature over canonical bytes
}

message BehaviorAttestation {
  AttestationId attestation_id = 1;
  WorldId world = 2;
  uint64 epoch_id = 3;
  ChallengeId challenge_id = 4;
  TargetRef target_ref = 5;
  optional FAH target_fah = 6;
  MetricsVector metrics = 7;
  EvidenceCommitment evidence_commitment = 8;
  optional bytes freshness_anchor = 9; // optional external anchor bytes
  bytes prober_transport_pubkey = 10;
  bytes signature = 11;
}

message DisputeEvent {
  WorldId world = 1;
  uint64 epoch_id = 2;
  EventId a = 3;
  EventId b = 4;
  string reason = 5;
  bytes disputer_transport_pubkey = 6;
  bytes signature = 7;
}

message LinkHintEvent {
  WorldId world = 1;
  uint64 epoch_id = 2;
  // Link hints are control-plane evidence suggesting that two TargetRefs should be treated as the same
  // underlying provider/class for aggregation (statistical; NOT a global identity).
  TargetRef a = 3;
  TargetRef b = 4;
  EvidenceCommitment evidence_commitment = 5;
  double compatibility_score = 6;
  bytes signer_transport_pubkey = 7;
  bytes signature = 8;
}

// Unsigned descriptor content (hashed to produce DescriptorId)
message ProviderDescriptorUnsigned {
  WorldId world = 1;
  uint64 descriptor_epoch = 2;
  repeated string contact_points = 3; // MUST be sorted lexicographically and deduped
  oneof capability {
    FAH fah = 4;
    CapabilityManifest capability_manifest = 5;
  }
}

// Signed wrapper (descriptor_id MUST equal computed hash of unsigned)
message ProviderDescriptor {
  DescriptorId descriptor_id = 1; // = BLAKE3("descriptor" || canonical_bytes(unsigned))
  ProviderDescriptorUnsigned unsigned = 2;
  bytes provider_transport_pubkey = 3;
  bytes signature = 4; // Ed25519 over ("desc-sig" || world_id || descriptor_id || canonical_bytes(unsigned))
}

// DescriptorPublishEvent wraps a descriptor for gossip.
// Validity is established by the provider's signature on the descriptor itself;
// no additional event-level signature is required.
message DescriptorPublishEvent {
  WorldId world = 1;
  uint64 epoch_id = 2;
  ProviderDescriptor descriptor = 3;
}

message RuleEndorsementEvent {
  WorldId world = 1;
  uint64 epoch_id = 2;
  Bytes32 rule_bundle_hash = 3;
  double weight = 4;
  bytes signer_transport_pubkey = 5;
  bytes signature = 6;
}

message TrainingDataShard {
  Bytes32 shard_id = 1;
  string source_type = 2;
  bytes redacted_payload = 3;
  Bytes32 payload_digest = 4;
  bytes curator_transport_pubkey = 5;
  bytes signature = 6;
}

message VerdictEvent {
  WorldId world = 1;
  uint64 epoch_id = 2;
  Bytes32 shard_id = 3;
  string verdict = 4; // "accept"/"reject"/"quarantine"
  repeated string reasons = 5;
  bytes verifier_transport_pubkey = 6;
  bytes signature = 7;
}

message TrainingManifest {
  Bytes32 manifest_id = 1;
  string base_model_id = 2;
  Bytes32 model_artifact_digest = 3;
  repeated Bytes32 shard_ids = 4;
  string method = 5; // "lora"/"qlora"/etc
  bytes eval_report_digest = 6;
  bytes trainer_transport_pubkey = 7;
  bytes signature = 8;
}

message Event {
  EventId event_id = 1;
  EventType type = 2;
  oneof body {
    ProbeReceipt receipt = 10;
    BehaviorAttestation attestation = 11;
    DisputeEvent dispute = 12;
    LinkHintEvent link_hint = 13;
    RuleEndorsementEvent rule_endorsement = 14;
    TrainingDataShard shard = 15;
    VerdictEvent verdict = 16;
    TrainingManifest training_manifest = 17;
    DescriptorPublishEvent descriptor_publish = 18;
  }
}

message VersionVectorEntry {
  // Rotating replica ID (recommended: rotate at least per epoch)
  // Example: replica_id = BLAKE3("replica" || transport_pubkey || world_id || epoch_id)
  Bytes32 replica_id = 1;
  uint64 counter = 2;
}

// Inference-plane circuit messages (minimal v0 schema)
message CircuitCreate {
  uint64 circuit_id = 1;
  bytes entry_ephemeral_pubkey = 2; // X25519
  uint32 desired_hops = 3;
}

message CircuitExtend {
  uint64 circuit_id = 1;
  // Option A: include descriptor inline (simpler, larger messages)
  // Option B: use DescriptorId and fetch via GetDescriptor RPC before circuit build
  oneof next_hop {
    DescriptorId next_hop_descriptor_id = 2;
    ProviderDescriptor next_hop_descriptor_inline = 5;
  }
  bytes hop_ephemeral_pubkey = 3; // X25519
}

// Control-plane RPC to fetch a descriptor by ID (used when CircuitExtend uses descriptor_id)
message GetDescriptorRequest {
  WorldId world = 1;
  DescriptorId descriptor_id = 2;
}

message GetDescriptorResponse {
  ProviderDescriptor descriptor = 1; // absent if not found
}

// Onion cell for inference-plane data.
// Uses AEAD (ChaCha20-Poly1305 or AES-256-GCM).
// associated_data for AEAD = (world_id || circuit_id || seq)
// ciphertext includes the AEAD authentication tag.
message OnionCell {
  uint64 circuit_id = 1;
  uint64 seq = 2;
  bytes ciphertext = 3; // includes AEAD tag; fixed size if RuleBundle.fixed_cell_bytes > 0
}

message CircuitDestroy {
  uint64 circuit_id = 1;
  string reason = 2;
}

message DeltaSyncRequest {
  WorldId world = 1;
  repeated VersionVectorEntry since = 2;
  uint32 max_events = 3;
}

message DeltaSyncResponse {
  WorldId world = 1;
  repeated Event events = 2;
  repeated VersionVectorEntry now = 3;
}

message SemanticQuery {
  WorldId world = 1;
  bytes embedding = 2;
  uint32 top_k = 3;
  string filter_type = 4; // optional
}

message SemanticQueryResult {
  repeated EventId event_ids = 1;
}
```

⸻

## 12. Reference Belief Update (Normative Guidance)

Belief is local, computed from events.

### 12.1 State

Per handle/class:
	•	mu (expected quality)
	•	sigma (uncertainty)
	•	trend (EWMA of delta)
	•	disagreement (robust dispersion of recent observations)

Per prober:
	•	trust in [0,1]
	•	correlation_cluster_id (optional)
	•	recent_accuracy measures

### 12.2 Observation Mapping

Each receipt/attestation is mapped to an observation x ∈ [-1, +1] by:
	•	weighted sum of normalized metrics, using RuleBundle weights
	•	penalize high latency and inconsistency

### 12.3 Robust Aggregation

Combine observations with:
	•	median / trimmed mean
	•	outlier rejection based on MAD
This resists lying egress nodes.

### 12.4 Trust Update (Predictiveness)

Update trust(prober) based on whether their observations predict later robust aggregates under diversity constraints.

⸻

## 13. Implementation Notes (Rust + TypeScript)

### 13.1 Rust: Canonical bytes and signatures
	•	Implement canonical_bytes() for every signed/hashed struct.
	•	Use domain separation strings as in §3.
	•	Provide test vectors for WorldId, FAH, receipt ids.

### 13.2 TypeScript: Mirror types and verify test vectors
	•	Do not invent hash logic; reproduce exactly from Rust vectors.
	•	Keep transport simple initially (HTTP/gRPC over TLS) and add onion layering at the application level.

### 13.3 Provider blindness enforcement
	•	Provider process never receives observer handles.
	•	Router maintains handle mapping privately.
	•	Logs must not include handles for self.

### 13.4 Vector memory storage
	•	Store event summaries + embeddings (not raw user prompts).
	•	Delta sync ingestion triggers incremental index updates.

⸻

## 14. Test Plan (MUST EXIST BEFORE IMPLEMENTATION)

### 14.1 Determinism
	•	WorldId derivation matches test vectors.
	•	Phrase address roundtrip + checksum failure.
	•	FAH derivation stable.

### 14.2 Protocol safety invariants
	•	“No canonical score”: ensure no message contains an authoritative score field.
	•	Provider blindness: ensure provider API never returns handle; ensure logs scrub.

### 14.3 Convergence and robustness (Simulation)
	•	Convergence to good providers under honest probers.
	•	Fast divergence when a provider degrades mid-run.
	•	Robustness under liar fraction f (e.g., 20% egress liars).
	•	Anti-correlation: cartel of probers cannot dominate without diversity.

### 14.4 Delta sync correctness
	•	No duplicate events.
	•	Version vector monotonicity.
	•	Reindex on ingestion produces consistent search results.

⸻

## 15. Security and Privacy Considerations
	•	Onion routing reduces linkability but does not defeat global correlation.
	•	Egress probers are noisy sensors; robust aggregation and redundancy required.
	•	Handle blindness reduces metric gaming but complicates debugging; provide safe redacted diagnostics.
	•	Worlds fork; social coordination is expected and supported.

⸻

## 16. Appendix: TypeScript and Rust Stubs (Normative Shapes)

### 16.1 TypeScript Types (packages/proto/src/types.ts)

```ts
export type Bytes32 = Uint8Array; // length 32
export type WorldId = Bytes32;
export type FAH = Bytes32;
export type Handle = Bytes32;
export type BAH = Bytes32;
export type EventId = Bytes32;
export type TargetRef = Bytes32;
export type DescriptorId = Bytes32;

export interface RuleBundle {
  version: number;
  epochLenMs: bigint;
  explorationRate: number;
  disagreementQuarantineThreshold: number;
  minDiverseProbers: number;
  maxProbeRedundancy: number;
  defaultCircuitLen: number;
  relayBatchMaxDelayMs: number;
  fixedCellBytes: number;
  weights: {
    success: number;
    toolFidelity: number;
    latency: number;
    refusalConsistency: number;
    robustness: number;
  };
}

export interface CapabilityManifest {
  baseModelId: string;
  weightsDigest: Bytes32;
  runtimeId: string;
  contextLimit: number;
  toolSchemasDigest: Bytes32;
  safetyMode: string;
  adapters: Array<{ adapterId: string; adapterDigest: Bytes32; adapterType: string }>;
}

export interface ProbeReceipt {
  receiptId: Bytes32;
  world: WorldId;
  epochId: bigint;
  challengeId: Bytes32;
  targetRef: TargetRef;
  targetFah?: FAH;
  outcomeCommitment: Bytes32;
  ticket?: { ticketBytes: Uint8Array; n: number; r: number; p: number };
  proberTransportPubKey: Uint8Array;
  signature: Uint8Array;
}

export interface BehaviorAttestation {
  attestationId: Bytes32;
  world: WorldId;
  epochId: bigint;
  challengeId: Bytes32;
  targetRef: TargetRef;
  targetFah?: FAH;
  metrics: {
    successRate: number;
    refusalConsistency: number;
    toolFidelity: number;
    latencyP50Ms: number;
    latencyP95Ms: number;
    robustnessScore: number;
    driftIndicator: number;
    freshness: "none" | "weak" | "strong";
  };
  evidenceCommitment: Bytes32;
  freshnessAnchor?: Uint8Array;
  proberTransportPubKey: Uint8Array;
  signature: Uint8Array;
}

export type Event =
  | { type: "receipt"; eventId: EventId; receipt: ProbeReceipt }
  | { type: "attestation"; eventId: EventId; attestation: BehaviorAttestation }
  | { type: "dispute"; eventId: EventId; a: EventId; b: EventId; reason: string; signer: Uint8Array; signature: Uint8Array }
  | { type: "linkHint"; eventId: EventId; a: TargetRef; b: TargetRef; evidenceCommitment: Bytes32; compatibilityScore: number; signer: Uint8Array; signature: Uint8Array }
  | { type: "ruleEndorsement"; eventId: EventId; ruleBundleHash: Bytes32; weight: number; signer: Uint8Array; signature: Uint8Array }
  | { type: "descriptorPublish"; eventId: EventId; descriptor: ProviderDescriptor };

export interface ProviderDescriptorUnsigned {
  world: WorldId;
  descriptorEpoch: bigint;
  contactPoints: string[]; // MUST be sorted and deduped
  capability: { type: "fah"; fah: FAH } | { type: "manifest"; manifest: CapabilityManifest };
}

export interface ProviderDescriptor {
  descriptorId: DescriptorId; // = BLAKE3("descriptor" || canonical_bytes(unsigned))
  unsigned: ProviderDescriptorUnsigned;
  providerTransportPubKey: Uint8Array;
  signature: Uint8Array; // Ed25519 over ("desc-sig" || world_id || descriptor_id || canonical_bytes(unsigned))
}
```

### 16.2 Rust Types (crates/terrain-gossip-core/src/types.rs)

```rs
use serde::{Serialize, Deserialize};

pub type Bytes32 = [u8; 32];

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct WorldId(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct Fah(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct Handle(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct TargetRef(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct DescriptorId(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct Bah(pub Bytes32);

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct EventId(pub Bytes32);

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RuleBundle {
  pub version: u32,
  pub epoch_len_ms: u64,
  pub exploration_rate: f64,
  pub disagreement_quarantine_threshold: f64,
  pub min_diverse_probers: u32,
  pub max_probe_redundancy: u32,
  pub default_circuit_len: u32,
  pub relay_batch_max_delay_ms: u32,
  pub fixed_cell_bytes: u32,
  pub w_success: f64,
  pub w_tool_fidelity: f64,
  pub w_latency: f64,
  pub w_refusal_consistency: f64,
  pub w_robustness: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CapabilityManifest {
  pub base_model_id: String,
  pub weights_digest: Bytes32,
  pub runtime_id: String,
  pub context_limit: u32,
  pub tool_schemas_digest: Bytes32,
  pub safety_mode: String,
  pub adapters: Vec<Adapter>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Adapter {
  pub adapter_id: String,
  pub adapter_digest: Bytes32,
  pub adapter_type: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProbeReceipt {
  pub receipt_id: Bytes32,
  pub world: WorldId,
  pub epoch_id: u64,
  pub challenge_id: Bytes32,
  pub target_ref: TargetRef,
  pub target_fah: Option<Fah>,
  pub outcome_commitment: Bytes32,
  pub ticket: Option<ProbeTicket>,
  pub prober_transport_pubkey: Vec<u8>,
  pub signature: Vec<u8>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProbeTicket {
  pub ticket_bytes: Vec<u8>,
  pub params_n: u32,
  pub params_r: u32,
  pub params_p: u32,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MetricsVector {
  pub success_rate: f64,
  pub refusal_consistency: f64,
  pub tool_fidelity: f64,
  pub latency_p50_ms: u32,
  pub latency_p95_ms: u32,
  pub robustness_score: f64,
  pub drift_indicator: f64,
  pub freshness: u8, // 0 none, 1 weak, 2 strong
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BehaviorAttestation {
  pub attestation_id: Bytes32,
  pub world: WorldId,
  pub epoch_id: u64,
  pub challenge_id: Bytes32,
  pub target_ref: TargetRef,
  pub target_fah: Option<Fah>,
  pub metrics: MetricsVector,
  pub evidence_commitment: Bytes32,
  pub freshness_anchor: Option<Vec<u8>>,
  pub prober_transport_pubkey: Vec<u8>,
  pub signature: Vec<u8>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum DescriptorCapability {
  Fah(Fah),
  Manifest(CapabilityManifest),
}

/// Unsigned descriptor content (hashed to produce DescriptorId)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProviderDescriptorUnsigned {
  pub world: WorldId,
  pub descriptor_epoch: u64,
  pub contact_points: Vec<String>, // MUST be sorted and deduped
  pub capability: DescriptorCapability,
}

/// Signed wrapper (descriptor_id MUST equal computed hash of unsigned)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProviderDescriptor {
  pub descriptor_id: DescriptorId,
  pub unsigned: ProviderDescriptorUnsigned,
  pub provider_transport_pubkey: Vec<u8>,
  pub signature: Vec<u8>,
}
```

⸻

## 17. Copilot Execution Instructions (Strict)

When implementing from this RFC:
	1.	Generate docs first (this RFC + threat model + protocol doc + test plan).
	2.	Generate protobuf schema and language stubs.
	3.	Add Rust canonical encoding + hash functions + test vectors.
	4.	Add TS mirror + test vector validation.
	5.	Only then implement daemons:
	•	gossipd (event log + delta sync + vector memory)
	•	routerd (belief field + routing)
	•	prober (bench harness generating receipts/attestations)
	•	infernode (provider wrapper)
	6.	Add simulator to validate convergence and liar robustness before deploying on the open internet.

Hard failure conditions:
	•	Any authoritative score field is introduced into gossip.
	•	Provider can query or infer its own external handle.
	•	WorldId does not commit to rule bundle hash.
	•	Hash/canonical bytes mismatch between Rust and TS.

⸻

---

## Notes on “will pass”
This spec is written to “pass” in the sense that it prevents the exact failure modes your earlier README drifted into:

- **No blockchain/credit/duel detour**
- **No canonical score payloads**
- **No stable global node identity used for routing**
- **World forks by rule hash**
- **Vector-memory + delta sync are first-class**
- **Benchmark receipts/attestations are the evidence substrate**
- **LoRA/training is explicitly optional and reputation reacts via measurement**
